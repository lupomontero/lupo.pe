{
  "id": "using-javascript-closures-to-create-private-scopes",
  "title": "Using JavaScript closures to create private scopes",
  "url": "https://lupomontero.com/using-javascript-closures-to-create-private-scopes/",
  "tags": [
    "javascript"
  ],
  "author": "lupo",
  "publishedAt": "2011-03-06T00:00:00.000Z",
  "body": "<p>One of the best known problems in JavaScript is it’s dependance on a global\nscope, which basically means that any variables you declare outside of a\nfunction live in the same name space: the ominous <code>window</code> object. Because of\nthe nature of web pages, many scripts from differnt sources can (and will) run\non the same page sharing a common global scope and this can be a really really\nbad thing as it can lead to name collisions (variables with the same names being\noverwritten) and security issues.</p>\n<p>To minimise the problem we can use JavaScript’s powerful closures to create\nprivate scopes where we can be sure our variables are invisible to other scripts\non the page.</p>\n<p>So what is a closure? Well, I could have used the definition given by\n<a href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\">Wikipedia</a>, but\nafter reading it myself I think we need a simpler, more practical explanation\nfor web developers.</p>\n<p>In JavaScript when you declare a function, the body of the function has access\nto its parent scope and its own local (private) scope. Closure means that\nfunctions close over the variables around them, so that functions created inside\nof another function still have access to the scope in which they were created\neven after the parent function has returned. Consider this:</p>\n<pre><code class=\"language-js\">var makeFunction = function () {\n  var foo = true;\n  return function () {\n    return foo;\n  };\n};\n\nvar myFunc = makeFunction();\nmyFunc(); // true\n</code></pre>\n<p>In the code above you can see that <code>makeFunction</code> returns an anonymous function,\nand this function still has access to <code>foo</code>.</p>\n<p>Closures together with anonymous functions can be used to achieve effective\n<em>private</em> scopes. If you have used any AJAX before you will have probably seen\nanonymous functions. This are functions that don’t have a name and are often\nused as callbacks passed as arguments when invoking a function that performs an\nasynchronous task. Something like:</p>\n<pre><code class=\"language-js\">foo('bar', function () {\n  //...\n});\n</code></pre>\n<p>But <em>anonymous</em> functions can also serve a different purpose: creating scope.\nAll variables declared inside a function are only visible inside that function\nand hidden from code outside. If we only want to create scope we don’t really\nneed to give the function a name, we only need to execute the function once so\nwe can just use the invokation operator on the anonymous function itself.</p>\n<pre><code class=\"language-js\">function () {\n  //...\n}();\n</code></pre>\n<p>The last <code>()</code> is the invokation operator. This syntax is a bit weird, so to make\nit easier to read you will normally see it like this:</p>\n<pre><code class=\"language-js\">(function () {\n  //...\n}());\n</code></pre>\n<p>Wrapping the function in parens makes it easier to see that something funny is\ngoing on with that function. The function is basically executing itself right\nafter being declared and since it is anonymous and hasn’t been assigned to any\nvariable it can not be referenced, effectively creating a private scope.</p>\n<p>This comes in very handy and is commonly used to wrap whole scripts, putting all\nyour code in a closure and then publishing a public interface on the <code>window</code>\nobject.</p>\n<pre><code class=\"language-js\">(function () {\n  var a = 'not foo again';\n  var foo = function (b) {\n    // do something funky with a and b\n  };\n  window.myPlugin = foo;\n}());\n</code></pre>\n<p>In the example above variable <code>a</code> is completely private, whereas <code>foo</code> has been\npublished on the <code>window</code> object under the name <code>myPlugin</code>, so from outside this\ncode <code>foo</code> can be called using <code>window.myPlugin()</code> or just <code>myPlugin()</code> because\n<code>window</code> is the global object. This is known as the module pattern and it is\nvery nicely explained by Ben Cherry in <a href=\"http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html\">this post</a>.</p>\n<p>This is also very common when writing <a href=\"http://jquery.com/\">jQuery</a> plugins. For\nexample, if we wanted to write a plugin that simply adds a class to the selected\nnodes (this is a bit silly but should do for the example) we can write something\nlike this:</p>\n<pre><code class=\"language-js\">(function ($) {\n  var a = 'just-a-classname';\n  $.fn.myPlugin = function () {\n    $(this).addClass(a);\n  };\n}(jQuery));\n</code></pre>\n<p>Note that we are passing <code>jQuery</code> to the anonymous function as a parameter and\nthat parameter is given the name of <code>$</code> inside it’s own local scope.</p>\n<p>So now after you have loaded jQuery and your plugin on the page you can add the\nclass name <code>just-a-classname</code> to all links by doing this:</p>\n<pre><code class=\"language-js\">jQuery('a').myPlugin();\n</code></pre>\n<p>I hope that if you read this far you found this post useful. Please leave a\ncomment and share your thoughts.</p>"
}